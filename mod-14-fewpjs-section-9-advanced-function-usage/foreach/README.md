---
description: 'Version 8: Module 14: Section 9: Lesson'
---

# forEach, the Unexpressive Enumerable (JS Advanced Functions)

`map()` and `reduce()` are "child" collection-processing methods from the root collection-processing method of them all: `forEach()`.

## Use `forEach()` to Work with an Array

You'll find that `forEach()` follows the pattern of the "character of collection-processing methods":

```javascript
let oppressedWorkers = [
  "Dopey",
  "Sneezy",
  "Happy",
  "Angry",
  "Doc",
  "Lemonjello",
  "Sleepy"
];

oppressedWorkers.forEach(function(oppressedWorker) {
  console.log(`${oppressedWorker} wants to form a union!`);
});

/* Output
Dopey wants to form a union!
Sneezy wants to form a union!
Happy wants to form a union!
Angry wants to form a union!
Doc wants to form a union!
Lemonjello wants to form a union!
Sleepy wants to form a union!
*/
```

We've saved talking about `forEach()` for last. Despite the fact that `forEach()` most simply expresses the "character of collection-processing methods," we're showing it _last_ because we want to use it _least_. Why is that?

## Explain Why `forEach` Is the Last-Expressive Collection-Processing Method

We want to avoid `forEach()` because it is the least-expressive collection-processing method. It communicates the _least_ to other programmers about what we're trying to do.

By now you recognize that `map()` means "create a new array after transforming each element." You recognize that `reduce()` means "distill a value after joining elements together." These methods are _expressive_â€”their very definition tells other programmers what you intended to happen.

But what does `forEach()` mean? Programmers, including you, recognize that `map()`, `reduce()`, `max()`, etc. all have specific uses, but `forEach()` is generic. This makes for code that's harder to understand and debug. We should always strive to have code that communicates _first_ and works _second_.

## Identify Cases for `forEach()`

The best time to use `forEach()` is when you need to enumerate a collection to (1) cause some sort of "side-effect" or (2) are changing the elements ("mutating") as you go along.

The best example of "doing a side-effect" is using `console.log()`. This function doesn't return anything back. We don't care about the data that returns from this action. We're using `forEach()` here strictly to do something that, as a _side-effect_ is handy for us (i.e. printing content to the screen).

This is pretty common in debugging:

```javascript
empCollection.forEach(function(e) {
  console.log("DEBUG: WHAT ARE YOU!?" + e);
});
```

The other time we want to use `forEach()` is when the element will be changed by the enumeration process. Since the name `forEach()` is **so** unexpressive, as casual readers of this code, anything that happens in here is going to be a surprise, a _side-effect_.

As an example, consider:

```javascript
function addFullNameToEmployees(empCollection) {
  empCollection.forEach(function(e) {
    e.fullName = `${e.firstName} ${e.familyName}`
  });
};

addFullNameToEmployees([
  { firstName: "Byron", familyName: "Karbitii },
  { firstName: "Luca", familyName: "Tuexedensis" }
]);
```

There's nothing generated by the `forEach()` that we want to preserve (if that were so, we'd want to use `map()`). The employee, `e`, is updated as a _side-effect_ of running `forEach()`. The only clue that helps us guess that `forEach()` is for here is that the programmer "wrapped" it inside of a helpfully-named function.

## Conclusion

`forEach()` is the most flexible collection-processing method, but it's also the least expressive. When you aren't sure which way to go, you might want to use it, but most of the time you're better off using `map()` or `reduce()`.
